parser grammar ExprParser;
options { tokenVocab=ExprLexer; }

program
    : stat+ EOF
    ;

code: (stat | cond)* EOF
    ;

stat: (expr | query | cond  | func |
func_call | loop_while ) '\n'*
    ;


query: BOOL  
    | query OP_BOOL query
    | NOT query
    | '(' query ')'
    | expr (LESSER | GREATER | EQ ) expr
    ;
    
cond: IF
    |ELSE
    |ELIF
    | IF query ':' stat (ELIF expr ':' stat)* (ELSE) ':' stat;



expr: ID
    | INT
    | FLOAT
    | COMPLEX
    | expr (MUL | DIVIDE) expr
    | expr (PLUS | MINUS) expr
    | expr EQ expr
    | '(' expr ')' 
    |func
    |func_call;
    
        
func : DEF ID '(' params ')' ':'// BL 
RETURN expr BL? ;

params: ( ID ',' ID* | ID |  'None')
  | (expr','expr* | expr | 'None');


func_call: ID '(' expr (','expr)* ')' ; 


loop_while: WHILE ( expr* | query* )
COLON
        stat* ;
expr: ID
    | INT
    | FLOAT
    | COMPLEX
    | expr (MUL | DIVIDE) expr
    | expr (PLUS | MINUS) expr
    | '(' expr ')' 
    |func
    |func_call;
    
        
func : DEF ID '(' params ')' ':'// BL RETURN expr BL? ;

params: ( ID ',' ID* | ID |  'None')
  | (expr','expr* | expr | 'None');


func_call: ID '(' expr (','expr)* ')' ; 

